
// Fixed Memory System with added episodic memory methods
// Auto-generated by fix-memory-system.js

const memorySystem = globalThis.MEMORY_SYSTEM || {};

// Add missing methods if they don't exist
if (!memorySystem.storeEpisode) {
  memorySystem.storeEpisode = function (
    conversationId,
    type,
    content,
    options = {}
  ) {
    console.log(
      `Storing episode with conversation ID: ${conversationId}, type: ${type}`
    );

    // Use episodic.store if available in db
    if (
      this.db &&
      this.db.episodic &&
      typeof this.db.episodic.store === "function"
    ) {
      return this.db.episodic.store(content, {
        type: type,
        conversationId: conversationId,
        importance: options.importance || 1,
        metadata: options.metadata,
      });
    }

    // If the object has an episodic object with a store method, use that
    if (this.episodic && typeof this.episodic.store === "function") {
      return this.episodic.store(content, {
        type: type,
        conversationId: conversationId,
        importance: options.importance || 1,
        metadata: options.metadata,
      });
    }

    // Fallback implementation
    if (!this._episodicMemory) {
      this._episodicMemory = [];
    }

    const episode = {
      id: Date.now(),
      conversation_id: conversationId,
      type: type,
      content: content,
      timestamp: Date.now(),
      importance: options.importance || 1,
    };

    this._episodicMemory.push(episode);
    console.log(`Episode stored with ID: ${episode.id}`);
    return episode.id;
  };
}

if (!memorySystem.getRecentEpisodes) {
  memorySystem.getRecentEpisodes = function (limit = 10) {
    console.log(`Getting recent episodes with limit: ${limit}`);

    // Use episodic.search if available in db
    if (
      this.db &&
      this.db.episodic &&
      typeof this.db.episodic.search === "function"
    ) {
      console.log("Using db.episodic.search method");
      return this.db.episodic.search("", { limit: limit, orderDesc: true });
    }

    // If the object has an episodic object with a search method, use that
    if (this.episodic && typeof this.episodic.search === "function") {
      console.log("Using episodic.search method");
      return this.episodic.search("", { limit: limit, orderDesc: true });
    }

    // Fallback implementation
    if (!this._episodicMemory) {
      console.log("No episodic memory found, returning empty array");
      return [];
    }

    const episodes = this._episodicMemory.slice(-limit);
    console.log(`Retrieved ${episodes.length} episodes`);
    return episodes;
  };
}

// Ensure the memory system is globally available
globalThis.MEMORY_SYSTEM = memorySystem;

// Export the memory system
module.exports = globalThis.MEMORY_SYSTEM;
